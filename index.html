<!DOCTYPE html>

<html>
<head>
  <title>@gratico/qbase</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="https://cdn.jsdelivr.net/npm/docco-next@0.9.3/layouts/parallel/docco.css" />
  <style>
    h1,h2,h3,h4,h5 {
      text-transform: none;
    }
    div.annotation pre {
        margin: 15px 0 15px;
        padding-left: 15px;
        background: #f5f5fe;
        box-shadow: none;
        border: 1px solid #ddd;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1">&#x00a7;</a>
              </div>
              <h1 id="graticoqbase">@gratico/qbase</h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-2">&#x00a7;</a>
              </div>
              <p>Simple active record like ORM for browser with MongoDB styled queries and watchable queries.</p>
<h2 id="install-and-use">Install and use</h2>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-3">&#x00a7;</a>
              </div>
              <p>To use run <code>npm install -g @gratico/qbase</code></p>
<pre><code><span class="hljs-keyword">import</span> {createStore} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@gratico/qbase&quot;</span>
<span class="hljs-keyword">const</span> store = createStore()</code></pre>
<h2 id="relational-helpers">relational helpers</h2>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-4">&#x00a7;</a>
              </div>
              <p>please check <a href="src/relational.html">relational module</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">import</span> {
  DB,
  defDb <span class="hljs-keyword">as</span> createDb,
  createRecord,
  getRecords,
  getShradCursorPath,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./relational&quot;</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-5">&#x00a7;</a>
              </div>
              <p>we also expose watchQuery inteface using <a href="https://abhishiv.github.io/atom/">@gratico/atom</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">import</span> { defWatchableCursor, ICommit } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@gratico/atom&quot;</span>;
<span class="hljs-keyword">import</span> { checksum } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@gratico/checksum&quot;</span>;
<span class="hljs-keyword">import</span> sift <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;sift&quot;</span>;
<span class="hljs-keyword">import</span> shortid <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;shortid&quot;</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-6">&#x00a7;</a>
              </div>
              <h2 id="createstore">createStore</h2>

            </div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-7">&#x00a7;</a>
              </div>
              <p>you can then attach queries to it and observe them for changes. To unobserver the call the function returned by observe</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createStore</span>(<span class="hljs-params">schema: ISchemaDefinition</span>): <span class="hljs-title">IDBStore</span> </span>{
  <span class="hljs-keyword">const</span> db = createDb();
  schema.tables.forEach(<span class="hljs-function">(<span class="hljs-params">table</span>) =&gt;</span> {
    createTable(db, table);
  });
  <span class="hljs-keyword">const</span> queryHandlers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">Function</span>&gt;&gt;();
  <span class="hljs-keyword">const</span> queries = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">string</span>, [ISelectQuery, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>]&gt;();
  <span class="hljs-keyword">const</span> store: IDBStore = {
    db,
    queryHandlers,
    queries,
    <span class="hljs-attr">observe</span>: <span class="hljs-function">(<span class="hljs-params">query: ISelectQuery, handler: <span class="hljs-built_in">Function</span></span>) =&gt;</span>
      observe(store, query, handler),
    schema,
  };
  <span class="hljs-keyword">return</span> store;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createTable</span>(<span class="hljs-params">db: DB, tableDefinition: ITableDefinition</span>) </span>{
  db.state[tableDefinition.name] = {
    <span class="hljs-attr">checksums</span>: {},
    <span class="hljs-attr">value</span>: {},
  };
  <span class="hljs-keyword">return</span> tableDefinition;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IDBStore {
  <span class="hljs-attr">db</span>: DB;
  queryHandlers: <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">Function</span>&gt;&gt;;
  queries: <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">string</span>, [ISelectQuery, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>]&gt;;
  observe: <span class="hljs-built_in">Function</span>;
  schema: ISchemaDefinition;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-8">&#x00a7;</a>
              </div>
              <h2 id="schema-definition">Schema Definition</h2>

            </div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-9">&#x00a7;</a>
              </div>
              <p>List of table describing their column and realtions</p>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> schema: ISchemaDefinition = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Kernel&quot;</span>,
  <span class="hljs-attr">tables</span>: [
    {
      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Masters&quot;</span>,
      <span class="hljs-attr">primaryKey</span>: [<span class="hljs-string">&quot;id&quot;</span>],
      <span class="hljs-attr">relations</span>: [
        [
          R.MTM,
          <span class="hljs-string">&quot;viewports&quot;</span>,
          {
            <span class="hljs-attr">tableName</span>: <span class="hljs-string">&quot;Viewports&quot;</span>,
            <span class="hljs-attr">remoteKey</span>: <span class="hljs-string">&quot;viewportId&quot;</span>,
            <span class="hljs-attr">localKey</span>: <span class="hljs-string">&quot;masterId&quot;</span>,
            <span class="hljs-attr">through</span>: <span class="hljs-string">&quot;MasterViewportJunction&quot;</span>,
          },
        ],
      ],
      <span class="hljs-attr">columns</span>: [
        { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;STRING&quot;</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;createdAt&quot;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;DATE_TIME&quot;</span>, <span class="hljs-attr">nullable</span>: <span class="hljs-literal">true</span> },
      ],
    } <span class="hljs-keyword">as</span> ITableDefinition,
  ],
};</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ISchemaDefinition {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  tables: ITableDefinition[];
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ITableDefinition {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  primaryKey?: <span class="hljs-built_in">string</span>[];
  columns: IColumnDefinition[];
  indexes?: IIndex[];
  relations?: ITableRelation[];
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IColumnDefinition {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;NUMBER&quot;</span> | <span class="hljs-string">&quot;INTEGER&quot;</span> | <span class="hljs-string">&quot;STRING&quot;</span> | <span class="hljs-string">&quot;BOOLEAN&quot;</span> | <span class="hljs-string">&quot;DATE_TIME&quot;</span> | <span class="hljs-string">&quot;OBJECT&quot;</span>;
  nullable?: <span class="hljs-built_in">boolean</span>;
  foreignKey?: IForeignKeyDefinition;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IIndex {
  <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;INDEX&quot;</span>;
  name: <span class="hljs-built_in">string</span>;
  columns: [<span class="hljs-built_in">string</span>, <span class="hljs-string">&quot;DESC&quot;</span> | <span class="hljs-string">&quot;ASC&quot;</span>][];
  unique?: <span class="hljs-built_in">boolean</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-10">&#x00a7;</a>
              </div>
              <h2 id="relations">Relations</h2>

            </div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-11">&#x00a7;</a>
              </div>
              <p>They can be Many to Many, Has Many, Belongs To, Has One Options are described as follows</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-built_in">enum</span> R {
  HM,
  BT,
  H1,
  MTM,
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> HasManyOptions {
  <span class="hljs-attr">foreignKey</span>: <span class="hljs-built_in">string</span>;
  tableName: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> HasOneOptions {
  <span class="hljs-attr">foreignKey</span>: <span class="hljs-built_in">string</span>;
  tableName: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> BelongsOptions {
  <span class="hljs-attr">foreignKey</span>: <span class="hljs-built_in">string</span>;
  tableName: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ManyToManyOptions {
  <span class="hljs-attr">remoteKey</span>: <span class="hljs-built_in">string</span>;
  localKey: <span class="hljs-built_in">string</span>;
  tableName: <span class="hljs-built_in">string</span>;
  through: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> ORDER = <span class="hljs-string">&quot;ASC&quot;</span> | <span class="hljs-string">&quot;DESC&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> ITableRelation =
  | [R.HM, <span class="hljs-built_in">string</span>, HasManyOptions]
  | [R.BT, <span class="hljs-built_in">string</span>, BelongsOptions]
  | [R.H1, <span class="hljs-built_in">string</span>, HasOneOptions]
  | IManyToMany;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IManyToMany = [R.MTM, <span class="hljs-built_in">string</span>, ManyToManyOptions];

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IForeignKeyDefinition {
  <span class="hljs-attr">ref</span>: <span class="hljs-built_in">string</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-12">&#x00a7;</a>
              </div>
              <h2 id="query-matchers">Query Matchers</h2>

            </div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-13">&#x00a7;</a>
              </div>
              <p>MongoDB styled query matches</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-built_in">enum</span> M {
  $and,
  $or,
  $eq,
  $neq,
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IAndQuery = [M.$and, IPredicate[]];
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IOrQuery = [M.$or, IPredicate[]];
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IEqQuery = [M.$eq, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>];
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> INeqQuery = [M.$neq, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>];
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IPredicate = IAndQuery | IOrQuery | IEqQuery | INeqQuery;</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-14">&#x00a7;</a>
              </div>
              <h2 id="queries">Queries</h2>

            </div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-15">&#x00a7;</a>
              </div>
              <p>Queries supported are SELECT, UPDATE, INSERT, DESTROY</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-built_in">enum</span> Q {
  SELECT,
  UPDATE,
  INSERT,
  DESTROY,
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ISelectCriterion {
  <span class="hljs-attr">columns</span>: <span class="hljs-built_in">string</span>[];
  order?: [<span class="hljs-built_in">string</span>, ORDER]; <span class="hljs-comment">// NIMP</span>
  includes?: <span class="hljs-built_in">string</span>[];
  predicate?: IPredicate;
  limit?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// NIMP</span>
  skip?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// NIMP</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> ISelectQuery = [Q.SELECT, <span class="hljs-built_in">string</span>, ISelectCriterion];
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IInsertQuery = [Q.INSERT, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>[]];

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IUpdateCiterion {
  <span class="hljs-attr">values</span>: <span class="hljs-built_in">Array</span>&lt;[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>]&gt;;
  predicate: IPredicate;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IUpdateQuery = [Q.UPDATE, <span class="hljs-built_in">string</span>, IUpdateCiterion];
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IDestroyCiterion {
  <span class="hljs-attr">predicate</span>: IPredicate;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IDestroyQuery = [Q.DESTROY, <span class="hljs-built_in">string</span>, IDestroyCiterion];
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IQuery = ISelectQuery | IInsertQuery | IUpdateQuery | IDestroyQuery;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInsert</span>(<span class="hljs-params">db: IDBStore, query: IInsertQuery</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> tableName = query[<span class="hljs-number">1</span>];
    <span class="hljs-keyword">const</span> rows = query[<span class="hljs-number">2</span>].map(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> el);

    rows.forEach(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> {
      createRecord(db.db, tableName, {}, row.id, row);
    });
  };
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDestroy</span>(<span class="hljs-params">db: IDBStore, query: IDestroyQuery</span>) </span>{}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUpdate</span>(<span class="hljs-params">db: IDBStore, query: IUpdateQuery</span>) </span>{}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSelect</span>(<span class="hljs-params">db: IDBStore, query: ISelectQuery</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> tableDef = getTableDefinition(db, query[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">const</span> table = getRecords(db.db, tableDef.name);
    <span class="hljs-keyword">const</span> list = <span class="hljs-built_in">Object</span>.values(table.value || {});
    <span class="hljs-keyword">const</span> siftQuery = sift(compilePredicate(db, query));
    <span class="hljs-keyword">const</span> filtered = list.filter(siftQuery);
    <span class="hljs-keyword">const</span> includeResults: { [key: <span class="hljs-built_in">string</span>]: { [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>[] } } = {};
    (query[<span class="hljs-number">2</span>].includes || []).forEach(<span class="hljs-function">(<span class="hljs-params">includeName: <span class="hljs-built_in">string</span></span>) =&gt;</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-16">&#x00a7;</a>
              </div>
              <p>performance</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">let</span> includeMap = includeResults[includeName];
      <span class="hljs-keyword">if</span> (!includeMap) {
        includeMap = {};
        includeResults[includeName] = includeMap;
      }
      <span class="hljs-keyword">const</span> results: <span class="hljs-built_in">Array</span>&lt;[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>[]]&gt; = compileIncludeQuery(
        db,
        query,
        tableDef,
        filtered,
        includeName
      );
      results.forEach(<span class="hljs-function">(<span class="hljs-params">[id, values]</span>) =&gt;</span> {
        includeMap[id] = values;
      });
    });

    <span class="hljs-keyword">return</span> filtered.map(<span class="hljs-function">(<span class="hljs-params">record: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> {
        ...record,
        ...Object.keys(includeResults).reduce(
          <span class="hljs-function">(<span class="hljs-params">state: <span class="hljs-built_in">any</span>, includeName: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
            <span class="hljs-keyword">const</span> result = includeResults[includeName][record.id];
            <span class="hljs-keyword">const</span> relation = getRelationDefintion(db, tableDef, includeName);
            <span class="hljs-keyword">const</span> isMultiple = [R.HM, R.MTM].indexOf(relation[<span class="hljs-number">0</span>]) &gt; -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">return</span> {
              ...state,
              [includeName]: result
                ? isMultiple
                  ? result
                  : result[<span class="hljs-number">0</span>]
                : <span class="hljs-literal">undefined</span>,
            };
          },
          {}
        ),
      };
    });
  };
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compilePredicate</span>(<span class="hljs-params">
  db: IDBStore,
  query: ISelectQuery | IUpdateQuery | IDestroyQuery,
  predicate: IPredicate = query[<span class="hljs-number">2</span>].predicate <span class="hljs-keyword">as</span> IPredicate
</span>) </span>{
  <span class="hljs-keyword">if</span> (!predicate) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NO_PREDICATE&quot;</span>);
  }
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">type</span> = predicate[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">const</span> columnName = predicate[<span class="hljs-number">1</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">const</span> value = predicate[<span class="hljs-number">2</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === M.$eq) {
    <span class="hljs-keyword">return</span> { [columnName]: { <span class="hljs-attr">$eq</span>: value } };
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> == M.$and) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">$and</span>: value.map(<span class="hljs-function">(<span class="hljs-params">el: IPredicate</span>) =&gt;</span> compilePredicate(db, query, el)),
    };
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === M.$or) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">$or</span>: value.map(<span class="hljs-function">(<span class="hljs-params">el: IPredicate</span>) =&gt;</span> compilePredicate(db, query, el)),
    };
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === M.$neq) {
    <span class="hljs-keyword">return</span> { [columnName]: { <span class="hljs-attr">$neq</span>: value } };
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;INVALID PREDICATE = &quot;</span> + <span class="hljs-keyword">type</span>);
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTableDefinition</span>(<span class="hljs-params">
  db: IDBStore,
  tableName: <span class="hljs-built_in">string</span>
</span>): <span class="hljs-title">ITableDefinition</span> </span>{
  <span class="hljs-keyword">const</span> table = db.schema.tables.find(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> el.name == tableName);
  <span class="hljs-keyword">if</span> (!table) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;no_table &quot;</span> + tableName);
  <span class="hljs-keyword">return</span> table;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRelationDefintion</span>(<span class="hljs-params">
  db: IDBStore,
  tableDef: ITableDefinition,
  includeName: <span class="hljs-built_in">string</span>
</span>) </span>{
  <span class="hljs-keyword">const</span> includeDef = (tableDef.relations || []).find(
    <span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> el[<span class="hljs-number">1</span>] === includeName
  );
  <span class="hljs-keyword">if</span> (!includeDef) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NO_RELATION = &quot;</span> + includeName);
  }
  <span class="hljs-keyword">return</span> includeDef;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileIncludeQuery</span>&lt;<span class="hljs-title">T</span> = <span class="hljs-title">any</span>&gt;(<span class="hljs-params">
  db: IDBStore,
  query: ISelectQuery,
  tableDef: ITableDefinition,
  tableRecords: <span class="hljs-built_in">any</span>[],
  includeName: <span class="hljs-built_in">string</span>
</span>): <span class="hljs-title">Array</span>&lt;[<span class="hljs-title">string</span>, <span class="hljs-title">T</span>[]]&gt; </span>{
  <span class="hljs-keyword">const</span> relationDefintion = getRelationDefintion(db, tableDef, includeName);
  <span class="hljs-keyword">if</span> (relationDefintion[<span class="hljs-number">0</span>] == R.MTM) {
    <span class="hljs-keyword">const</span> { tableName, through, remoteKey, localKey } = relationDefintion[<span class="hljs-number">2</span>];
    <span class="hljs-keyword">const</span> throughRecords = getRecords(db.db, through);
    <span class="hljs-keyword">const</span> throughQuery = sift({
      [localKey]: { <span class="hljs-attr">$in</span>: tableRecords.map(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> el.id) },
    });
    <span class="hljs-keyword">const</span> throughTableList = <span class="hljs-built_in">Object</span>.values(throughRecords.value);
    <span class="hljs-keyword">const</span> matchingRecords = throughTableList.filter(throughQuery);
    <span class="hljs-keyword">const</span> remoteMatchIds = matchingRecords.map(<span class="hljs-function">(<span class="hljs-params">el: <span class="hljs-built_in">any</span></span>) =&gt;</span> el[remoteKey]);

    <span class="hljs-keyword">const</span> resultTableRecords = getRecords(db.db, tableName);
    <span class="hljs-keyword">const</span> resultList = <span class="hljs-built_in">Object</span>.values(resultTableRecords.value);
    <span class="hljs-keyword">const</span> resultQuery = sift({ <span class="hljs-attr">id</span>: { <span class="hljs-attr">$in</span>: remoteMatchIds } });
    <span class="hljs-keyword">const</span> resultRecords: <span class="hljs-built_in">any</span>[] = resultList.filter(resultQuery);

    <span class="hljs-keyword">const</span> matchIndex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;();
    tableRecords.forEach(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> {
      matchIndex.set(
        el.id,
        <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(
          throughTableList
            .filter(<span class="hljs-function">(<span class="hljs-params">throughItem: <span class="hljs-built_in">any</span></span>) =&gt;</span> throughItem[localKey] === el.id)
            .map(<span class="hljs-function">(<span class="hljs-params">el: <span class="hljs-built_in">any</span></span>) =&gt;</span> el[remoteKey])
        )
      );
    });

    <span class="hljs-keyword">return</span> tableRecords.map(<span class="hljs-function">(<span class="hljs-params">tableRecord: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> [
        tableRecord.id,
        resultRecords.filter(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> {
          <span class="hljs-keyword">const</span> match = matchIndex.get(tableRecord.id);
          <span class="hljs-keyword">return</span> match &amp;&amp; match.has(el.id);
        }),
      ];
    });
  }
  <span class="hljs-keyword">return</span> [];
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span>(<span class="hljs-params">
  store: IDBStore,
  query: ISelectQuery,
  handler: <span class="hljs-built_in">Function</span>
</span>) </span>{
  <span class="hljs-keyword">const</span> id = shortid();
  <span class="hljs-keyword">const</span> queryHash = checksum(query);
  <span class="hljs-keyword">const</span> wid = id + <span class="hljs-string">&quot;/&quot;</span> + queryHash;
  <span class="hljs-keyword">const</span> tableDef = getTableDefinition(store, query[<span class="hljs-number">1</span>]);
  <span class="hljs-keyword">const</span> interestingTables = getRelatedTables(store, query, tableDef);
  <span class="hljs-keyword">const</span> shradCusor = defWatchableCursor(store.db, getShradCursorPath(store.db));
  shradCusor.addWatch(wid, <span class="hljs-function">(<span class="hljs-params">id, commit</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> dirtyTables = getDirtyTables(store, commit || []);
    <span class="hljs-keyword">const</span> isDirty = dirtyTables.some(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> interestingTables.has(el));
    <span class="hljs-built_in">console</span>.debug(<span class="hljs-string">&quot;interestingTables&quot;</span>, interestingTables, dirtyTables, isDirty);
    <span class="hljs-keyword">if</span> (isDirty) {
      <span class="hljs-built_in">console</span>.debug(dirtyTables, interestingTables, isDirty);
      handler();
    }
  });
  addHandler(store, query, wid, handler);
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
    shradCusor.removeWatch(wid);
    removeHandler(store, query, wid, handler);
  };
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDirtyTables</span>(<span class="hljs-params">store: IDBStore, commit: ICommit</span>) </span>{
  <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>(commit.map(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> el.path[<span class="hljs-number">0</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>))];
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRelatedTables</span>(<span class="hljs-params">
  store: IDBStore,
  query: ISelectQuery,
  tableDef: ITableDefinition
</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;([
    query[<span class="hljs-number">1</span>],
    ...Object.keys(query[<span class="hljs-number">2</span>].includes || []).reduce&lt;<span class="hljs-built_in">string</span>[]&gt;(
      <span class="hljs-function">(<span class="hljs-params">state: <span class="hljs-built_in">string</span>[], includeName: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> relation = getRelationDefintion(store, tableDef, includeName);
        <span class="hljs-keyword">if</span> (relation[<span class="hljs-number">0</span>] === R.MTM) {
          <span class="hljs-keyword">return</span> [
            ...state,
            relation[<span class="hljs-number">2</span>].tableName,
            relation[<span class="hljs-number">2</span>].through <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>,
          ];
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> state;
        }
      },
      [] <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>[]
    ),
  ]);
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addHandler</span>(<span class="hljs-params">
  store: IDBStore,
  query: ISelectQuery,
  wid: <span class="hljs-built_in">string</span>,
  handler: <span class="hljs-built_in">Function</span>
</span>) </span>{
  <span class="hljs-keyword">const</span> queryHash = checksum(query);
  <span class="hljs-keyword">let</span> exisitngDef = store.queries.get(queryHash);
  <span class="hljs-keyword">let</span> handlers = store.queryHandlers.get(queryHash);
  <span class="hljs-keyword">if</span> (!exisitngDef || !handlers) {
    store.queries.set(wid, [query, queryHash, wid]);
    handlers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([]);
    store.queryHandlers.set(queryHash, handlers);
  }
  <span class="hljs-keyword">if</span> (!handlers) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NODEF&quot;</span>);
  }
  handlers.add(handler);
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeHandler</span>(<span class="hljs-params">
  store: IDBStore,
  query: ISelectQuery,
  wid: <span class="hljs-built_in">string</span>,
  handler: <span class="hljs-built_in">Function</span>
</span>) </span>{
  <span class="hljs-keyword">const</span> exisitngDef = store.queries.get(wid);
  <span class="hljs-keyword">if</span> (!exisitngDef) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NO_WATCH&quot;</span>);
  }
  <span class="hljs-keyword">const</span> [q, queryHash] = exisitngDef;
  <span class="hljs-keyword">const</span> handlers = store.queryHandlers.get(queryHash);
  <span class="hljs-keyword">if</span> (!exisitngDef || !handlers) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;NODEF&quot;</span>);
  }
  handlers.delete(handler);
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
